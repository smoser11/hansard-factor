{
    "contents" : "// -*- mode: c++; fill-column: 70; -*-\n\n//////////////////////////////////////////////////////////////////////\n\n// Copyright 2012 Jesse Windle - jwindle@ices.utexas.edu\n\n// This program is free software: you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public License\n// as published by the Free Software Foundation, either version 3 of\n// the License, or (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// General Public License for more details.\n\n// You should have received a copy of the GNU Lesser General Public\n// License along with this program.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n//////////////////////////////////////////////////////////////////////\n// See appendix at end of document for additional information.\n//////////////////////////////////////////////////////////////////////\n\n#ifndef __MATRIX_FRAME__\n#define __MATRIX_FRAME__\n\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <stdexcept>\n#include <stdio.h>\n\n#ifndef DISABLE_FIO\n#include <fstream>\nusing std::ofstream;\nusing std::ifstream;\n#endif\n\n#ifdef USE_R\n#include <R_ext/Utils.h>\n#include <R_ext/PrtUtil.h>\n#endif\n\nusing std::vector;\nusing std::string;\nusing std::ostream;\nusing std::istream;\nusing std::stringstream;\nusing std::ostream;\n\n#ifndef uint\ntypedef unsigned int uint;\n#endif\n\n//////////////////////////////////////////////////////////////////////\n                          // MatrixFrame //\n//////////////////////////////////////////////////////////////////////\n\ninline bool idxcheck(bool b){\n#ifndef NDEBUG\n  if (!b) throw std::runtime_error(\"Index out of bounds.\\n\");\n  return b;\n#else\n  return true;\n#endif\n}\n\ninline bool sizecheck(bool b){\n#ifndef NDEBUG\n  if (!b) throw std::runtime_error(\"Incompatible dimension.\\n\");\n  return b;\n#else\n  return true;\n#endif\n}\n\ninline bool memcheck(bool b){\n#ifndef NDEBUG\n  if (!b) throw std::runtime_error(\"Memory overlap.\\n\");\n  return b;\n#else\n  return true;\n#endif\n}\n\ntemplate<typename SCLR>\nclass Frame\n{\n protected:\n  // I do not want to use *const p since I want to be able to resize my matrices.\n  SCLR *p;  // Pointer to the array of matrices.\n  uint nr;  // Number of rows.\n  uint nc;  // Number of columns.\n  uint nm;  // Number of matrices.\n\n  // Matrix Check\n  bool allow(uint l) const\n    { return (p!=NULL && l < (nr*nc)); }\n  bool allow(int  l) const\n    { return (p!=NULL && l>=0 && l < (int)(nr*nc)); }\n  bool allow(uint r, uint c) const\n    { return (p!=NULL && r < nr && c < nc); }\n  bool allow(int  r,  int c) const\n    { return (p!=NULL && r>=0 && c>=0 && r < (int)nr && c < (int)nc); }\n\n  // Array of Matrix Check\n  bool indexok(uint i) const\n  { return i < nm; }\n  bool indexok( int i) const\n  { return (0 <= i && i < (int)nm); }\n\n public:\n  // Constructors, etc.  Do not make a constructor which copies.\n  Frame()\n    { p = NULL; nr = 0; nc = 0; nm = 0; }\n  Frame(SCLR *ptr, uint r=1, uint c=1, uint m=1)\n    { p = ptr; nr = r; nc = c; nm = m; }\n  Frame(SCLR *ptr,  int r=1,  int c=1,  int m=1)\n    { p = ptr; nr = (uint)r; nc = (uint)c; nm = (uint)m; }\n  Frame(const Frame<SCLR> & M)\n    { p = M.p; nr = M.nr; nc = M.nc; nm = M.nm; }\n\n  ~Frame()\n    { p = NULL; }\n\n  // Test equality and assign equality.\n  Frame<SCLR>& operator= (const Frame<SCLR> &M); // Makes copy.\n  bool         operator==(const Frame<SCLR> &M) const;\n  bool         sameframe (const Frame<SCLR> &M) const;\n\n  // rows(), cols(), mats, area(), vol();\n  inline uint rows() const { return nr; }\n  inline uint cols() const { return nc; }\n  inline uint mats() const { return nm; }\n  inline uint area() const { return nr * nc; }\n  inline uint vol()  const { return nr * nc * nm; }\n  inline uint size() const { return nr * nc * nm; }\n\n  // Matrix Access\n\n  // Returns the (r,c) element of matrix.\n  SCLR& operator()(uint r, uint c)\n    { \n    #ifndef NDEBUG\n        idxcheck(allow(r, c)); \n    #endif      \n        return p[c * nr + r]; \n    }\n  const SCLR& operator()(uint r, uint c) const\n    { \n    #ifndef NDEBUG\n        idxcheck(allow(r, c)); \n    #endif\n        return p[c * nr + r]; \n    }\n\n  // Array of Matrix Access\n\n  // Returns the lth element of array of matrices.\n  // I debate whether this is confusing notation.\n  const SCLR& operator()(uint l) const\n    { \n    #ifndef NDEBUG\n        idxcheck(l < nr*nc*nm);    \n    #endif    \n        return p[l]; \n    }\n    \n  SCLR& operator()(uint l)\n    { \n    #ifndef NDEBUG\n        idxcheck(l < nr*nc*nm);   \n    #endif\n        return p[l]; \n    }\n\n  // Returns the (r,c) element of matrix[t].\n  SCLR& operator()(uint r, uint c, uint t)\n    {   \n    #ifndef NDEBUG  \n        idxcheck(indexok(t) && allow(r,c)); \n    #endif\n        return p[t * nr*nc + c * nr + r]; \n    }\n    \n  const SCLR& operator()(uint r, uint c, uint t) const\n    { \n    #ifndef NDEBUG\n        idxcheck(indexok(t) && allow(r,c)); \n    #endif\n        return p[t * nr*nc + c * nr + r]; \n    }    \n    \n  SCLR& get(uint r, uint c=0, uint t=0)\n  { idxcheck(indexok(t) && allow(r,c)); return p[t * nr*nc + c * nr + r]; }\n  const SCLR& get(uint r, uint c=0, uint t=0) const\n  { idxcheck(indexok(t) && allow(r,c)); return p[t * nr*nc + c * nr + r]; }\n\n  // Returns the ith element of the array p.\n  SCLR& vec(uint i)\n  { idxcheck(i < nr*nc*nm); return p[i]; }\n  const SCLR& vec(uint i) const\n  { idxcheck(i < nr*nc*nm); return p[i]; }\n\n  // Returns a Frame pointing to the ith matrix or,\n  // if there is one matrix, to the ith column.\n  Frame<SCLR> operator[](uint i)\n  { idxcheck(indexok(i)); return Frame<SCLR>(&p[0+i*area()], nr, nc); }\n\n  // Get the pointer.  Be wary.\n  // const double* const getp()\n  // { return p; }\n  inline SCLR* getp()\n  { return p; }\n  inline void setp(SCLR *p_)\n  { p = p_; }\n\n  // Array of Matrix Functions.\n\n  void copy(const Frame<SCLR>& M);     // Copy values.\n  // void thincopy(Frame& M);          // Copy pointer and dimensions.\n  Frame<SCLR> fill(const SCLR& x);            // Fill with value.\n  Frame<SCLR> col(uint c, uint num=1); // The c-th to c+num-1th col.\n  Frame<SCLR> dim(uint r, uint c, uint m=1); // Return a MF with different, compatible dim.\n\n  // Read / Write.\n\n  bool write(      ostream&  os, bool header=0, bool binary=0);\n  uint  scan(      istream&  is, bool header=0, bool binary=0);\n\n  #ifndef DISABLE_FIO\n  bool write(const string& file, bool header=0, bool binary=0);\n  uint  scan(const string& file, bool header=0, bool binary=0);\n  #endif\n  // bool  readstring(const string& s, bool header=0);\n\n  // Matrix Functions.\n\n  // Fill this matrix from M starting at (r,c).\n  void copy(const Frame<SCLR>& M, uint r, uint c);\n  // Copy the matrix M along rows rs and columns cs.\n  template<typename IDX> void copy(const Frame<SCLR>& M, const Frame<IDX>& rs, const Frame<IDX>& cs);\n  template<typename IDX> void copy(const Frame<SCLR>& M, const Frame<IDX>& rs, uint c);\n  template<typename IDX> void copy(const Frame<SCLR>& M, uint r, const Frame<IDX>& cs);\n  void copy_transpose(const Frame<SCLR>& M);\n\n  // Set the elements in rows rs and columns cs using the matrix M.\n  template<typename IDX> void set(const Frame<IDX>& rs, const Frame<IDX>& cs, const Frame<SCLR>& M);\n  template<typename IDX> void set(const Frame<IDX>& rs, uint c, const Frame<SCLR>& M);\n  template<typename IDX> void set(uint r, const Frame<IDX>& cs, const Frame<SCLR>& M);\n\n}; // MatrixFrame\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t    // TYPEDEF //\n//////////////////////////////////////////////////////////////////////\n\n#ifndef MF\ntypedef Frame<double> MF;\n#endif\n\n#ifndef MatrixFrame\ntypedef Frame<double> MatrixFrame;\n#endif\n\n//////////////////////////////////////////////////////////////////////\n\t\t       // WRAPPER TO FORTRAN //\n//////////////////////////////////////////////////////////////////////\n\n// y = alpha x + y.\ntemplate<typename SCLR>\nvoid axpy(SCLR alpha, Frame<SCLR> x, Frame<SCLR> y); \n\n // x'y\ntemplate<typename SCLR>\nSCLR dot(Frame<SCLR> x, Frame<SCLR> y);\n\n// c = alpha op(a) * op(b) + beta c.\ntemplate<typename SCLR>\nvoid gemm(Frame<SCLR> c, Frame<SCLR> a, Frame<SCLR> b, char ta='N', char tb='N', SCLR alpha=1.0, SCLR beta=0.0); \n\n// b = alpha op(a) * b  OR  b = alpha b * op(a) where a is triangular.\ntemplate<typename SCLR>\nvoid trmm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side='L', char ta='N', char diag='N', SCLR alpha=1.0);\n\n// Solve x:  op(a) x = alpha b  OR  x op(a) = alpha b, a triangular.\n// i.e: x = alpha inv(op(a)) b  OR  x = alpha b inv(op(a)).\n// The solution is overwriten into b.\ntemplate<typename SCLR>\nvoid trsm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side='L', char ta='N', char diag='N', SCLR alpha=1.0);\n\n// c = alpha a' a + beta c, ta='T'\n// c = alpha a a' + beta c, ta='N'\ntemplate<typename SCLR>\nvoid syrk(Frame<SCLR> c, Frame<SCLR> a, char ta='N', SCLR alpha=1.0, SCLR beta=0.0);\n\n// Solve a general linear system, ax = b for x.\ntemplate<typename SCLR>\nint gesv(Frame<SCLR> a, Frame<SCLR> b);\n\n// Solves ax = b for x where a is sym. pos. def.  Note: the lower (or\n// upper) portion of A is overwritten with the Cholesky decomposition.\ntemplate<typename SCLR>\nint posv(Frame<SCLR> a, Frame<SCLR> b, char uplo);\n\n// Cholesky Decomposition (in place)\ntemplate<typename SCLR>\nint potrf(Frame<SCLR> a, char uplo);\n\ntemplate<typename SCLR>\nint chol(Frame<SCLR> a, char uplo='L');\n\n//--------------------------------------------------------------------\n  \n// BLAS Level 1\n// BLAS Level 3\n// LAPACK\n\n#define BLASDEC(TYPE) \\\n  void raxpy(int n, TYPE da, TYPE* dx, int incx, TYPE* dy, int incy);\t\\\n  TYPE rdot(int n, TYPE* dx, int incx, TYPE* dy, int incy);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n  void rgemm(char transa, char transb, int m, int n, int k, TYPE alpha, TYPE* a, int lda, TYPE* b, int ldb, TYPE beta, TYPE* c, int ldc); \\\n  void rsyr2k(char uplo, char trans, int n, int k, TYPE alpha, TYPE* a, int lda, TYPE* b, int ldb, TYPE beta, TYPE* c, int ldc); \\\n  void rtrmm(char side, char uplo, char transa, char diag, int m, int n, TYPE alpha, TYPE* a, int lda, TYPE* b, int ldb); \\\n  void rtrsm(char side, char uplo, char transa, char diag, int m, int n, TYPE alpha, TYPE* a, int lda, TYPE* b, int ldb); \\\n  void rsyrk(char uplo, char trans, int n, int k, TYPE alpha, TYPE* a, int lda, TYPE beta, TYPE* c, int ldc); \\\n\t\t\t\t\t\t\t\t\t\\\n  void rgesv(int n, int nrhs, TYPE* a, int lda, int* ipiv, TYPE* b, int ldb, int& info); \\\n  void rposv(char uplo, int n, int nrhs, TYPE* a, int lda, TYPE* b, int ldb, int& info); \\\n  void rpotrf(char uplo, int n, TYPE* a, int lda, int& info);\n\nBLASDEC(double)\nBLASDEC(float)\n\n#undef BLASDEC\n\n//--------------------------------------------------------------------\nextern \"C\" {\n\n  // BLAS Level 1\n  // BLAS Level 3\n  // LAPACK\n\n  // double\n\n  void daxpy_(int* N, double* DA, double* DX, int* INCX, double* DY, int* INCY);\n  double ddot_(int* N, double* DX, int* INCX, double* DY, int* INCY);\n\n  void dgemm_(char* TRANSA, char* TRANSB, int* M, int* N, int* K, double* ALPHA, double* A, int* LDA, double* B, int* LDB, double* BETA, double* C, int* LDC);\n  void dsyr2k_(char* UPLO, char* TRANS, int* N, int* K, double* ALPHA, double* A, int* LDA, double* B, int* LDB, double* BETA, double* C, int* LDC);\n\n  void dtrmm_(char* SIDE, char* UPLO, char* TRANSA, char* DIAG, int* M, int* N, double* ALPHA, double* A, int* LDA, double* B, int* LDB);\n  void dtrsm_(char* SIDE, char* UPLO, char* TRANSA, char* DIAG, int* M, int* N, double* ALPHA, double* A, int* LDA, double* B, int* LDB);\n  void dsyrk_(char* UPLO, char* TRANS, int* N, int* K, double* ALPHA, double* A, int* LDA, double* BETA, double* C, int* LDC);\n\n  void dgesv_(int* N, int* NRHS, double* A, int* LDA, int* IPIV, double* B, int* LDB, int* INFO);\n  void dposv_(char* UPLO, int* N, int* NRHS, double* A, int* LDA, double* B, int* LDB, int* INFO);\n  void dpotrf_(char* UPLO, int* N, double* A, int* LDA, int* INFO);\n\n  // float\n \n  void saxpy_(int* N, float* DA, float* DX, int* INCX, float* DY, int* INCY);\n  float sdot_(int* N, float* DX, int* INCX, float* DY, int* INCY);\n\n  void sgemm_(char* TRANSA, char* TRANSB, int* M, int* N, int* K, float* ALPHA, float* A, int* LDA, float* B, int* LDB, float* BETA, float* C, int* LDC);\n  void ssyr2k_(char* UPLO, char* TRANS, int* N, int* K, float* ALPHA, float* A, int* LDA, float* B, int* LDB, float* BETA, float* C, int* LDC);\n\n  void strmm_(char* SIDE, char* UPLO, char* TRANSA, char* DIAG, int* M, int* N, float* ALPHA, float* A, int* LDA, float* B, int* LDB);\n  void strsm_(char* SIDE, char* UPLO, char* TRANSA, char* DIAG, int* M, int* N, float* ALPHA, float* A, int* LDA, float* B, int* LDB);\n  void ssyrk_(char* UPLO, char* TRANS, int* N, int* K, float* ALPHA, float* A, int* LDA, float* BETA, float* C, int* LDC);\n\n  void sgesv_(int* N, int* NRHS, float* A, int* LDA, int* IPIV, float* B, int* LDB, int* INFO);\n  void sposv_(char* UPLO, int* N, int* NRHS, float* A, int* LDA, float* B, int* LDB, int* INFO);\n  void spotrf_(char* UPLO, int* N, float* A, int* LDA, int* INFO);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t // IMPLEMENTATION //\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n                       // Utility Functions //\n//////////////////////////////////////////////////////////////////////\n\ntemplate<typename SCLR>\nvoid Frame<SCLR>::copy(const Frame<SCLR>& M)\n{\n  if (this==&M) return;\n  idxcheck(nr==M.rows() && nc==M.cols() && nm==M.mats());\n  for(uint i = 0; i < vol(); i++) p[i] = M.vec(i);\n} // copy\n\n// I am now forcing a person to do this only in a constructor.\n// void Frame::thincopy(Frame& M)\n// {\n//   if (this==&M) return;\n//   p  = &M(0);\n//   nr = M.rows();\n//   nc = M.cols();\n//   nm = M.mats();\n// } // thincopy\n\ntemplate<typename SCLR>\nFrame<SCLR> Frame<SCLR>::col(uint c, uint num)\n{\n  // Check that these are valid parameters.\n  idxcheck(allow((uint)0,c));\n  idxcheck(allow((uint)0,c+num-1));\n  double *ptr = &operator()(0,c);\n  return Frame<SCLR>(ptr, nr, num);\n}\n\ntemplate<typename SCLR>\nFrame<SCLR> Frame<SCLR>::fill(const SCLR& d)\n{\n  for(uint i = 0; i < vol(); i++) p[i] = d;\n  return *this;\n}\n\ntemplate<typename SCLR>\nFrame<SCLR> Frame<SCLR>::dim(uint r, uint c, uint m)\n{\n  sizecheck (r*c*m==nr*nc*nm);\n  return Frame<SCLR>(p, r, c, m);\n}\n\n//////////////////////////////////////////////////////////////////////\n                  // Assigment and Test equality //\n//////////////////////////////////////////////////////////////////////\n\n/*\n  The copy constructor and assignment operator work in two different\n  ways.  The copy constructor simply copies the pointer p, and\n  dimension info nr and nc into a new object.  These quantities are\n  all small and hence there isn't much overhead to this operation.\n\n  The assignment operator works differently.  It copies the contents\n  of one MatrixFrame into the contents of another MatrixFrame.  I\n  don't want to do this accidentally so I've included a warning.  In\n  general, you should not use assignement and instead you should use\n  the copy _function_.\n\n  My concern is that one could be using the derived class Matrix and\n  write something like c[i] = a[i], which seems to have the more\n  intuitive notion of copying the conents of matrix a[i] into matrix\n  c[i], but which is still ambiguous since one could just want to copy\n  an address.\n\n  To recap, the behavior you should expect:\n  shallow copy:\n    MatrixFrame mf1(mf2);\n    MatrixFrame mf1 = mf2;\n  hard copy:\n    MatrixFrame mf1, mf2;\n    mf1 = mf2;\n\n  Here is something I need to think about.\n  Matrix a, b;\n  a.col(i) = b.col(j);\n  or\n  Matrix a = b.col(j);\n\n */\n\n// Assignment.  See discussion above.\ntemplate<typename SCLR>\nFrame<SCLR>& Frame<SCLR>::operator= (const Frame<SCLR>& M)\n{\n  //cerr << \"Warning: be careful with the assignment operator.\\n\"\n  //     << \"MatrixFrame::operator= makes a deep copy.\\n\";\n  if (this==&M) return *this;\n  copy(M);\n  return *this;\n} // operator=\n\n// Test equality.\ntemplate<typename SCLR>\nbool Frame<SCLR>::operator==(const Frame<SCLR>& M) const\n{\n  if(sameframe(M)) return true;\n  if(vol() != M.vol()) return false;\n  for(uint i = 0; i < vol(); i++) if(M(i)!=operator()(i)) return false;\n  return true;\n} // operator==\n\ntemplate<typename SCLR>\nbool Frame<SCLR>::sameframe(const Frame<SCLR>& M) const\n{\n  return (p==&M(0) && nr==M.rows() && nc==M.cols() && nm==M.mats());\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t   // Comparison //\n//////////////////////////////////////////////////////////////////////\n\ntemplate<typename SCLR>\nFrame<SCLR> lt(Frame<SCLR> c, const Frame<SCLR>& a, const Frame<SCLR>& b)\n{\n  sizecheck(c.vol()==a.vol() && a.vol()==b.vol());\n  if(a.sameframe(b)) c.fill(1.0);\n  for(uint i = 0; i < a.vol(); i++)\n    c(i) = (double) (a(i) < b(i));\n  return c;\n}\n\ntemplate<typename SCLR>\nFrame<SCLR> lteq(Frame<SCLR> c, const Frame<SCLR>& a, const Frame<SCLR>& b)\n{\n  sizecheck(c.vol()==a.vol() && ( a.vol()%b.vol() )==0 );\n  if(a.sameframe(b)) c.fill(0.0);\n  for(uint i = 0; i < a.vol(); i++)\n    c(i) = (double) (a(i) <= b(i));\n  return c;\n}\n\ntemplate<typename SCLR>\nFrame<SCLR> between(Frame<SCLR> c, const Frame<SCLR> a, const Frame<SCLR> lower, const Frame<SCLR> upper)\n{\n  sizecheck(c.vol()==a.vol() && a.vol()==lower.vol() && lower.vol()==upper.vol());\n  for(uint i = 0; i < a.vol(); i++)\n    c(i) = (double) ( lower(i) <= a(i) && a(i) <= upper(i) );\n  return c;\n}\n\n// Frame<SCLR> within(Frame<SCLR> c, const Frame<SCLR> a, double lower, double upper)\n// {\n//   sizecheck(c.vol()==a.vol() && a.vol()==lower.vol() && lower.vol()==upper.vol());\n//   for(uint i = 0; i < a.vol(); i++)\n//     c(i) = (double) ( lower <= a(i) && a(i) <= upper );\n//   return c;\n// }\n\n//////////////////////////////////////////////////////////////////////\n\t\t    // Input / Output Operators //\n//////////////////////////////////////////////////////////////////////\n\n// Output matrix to stream.  This is done in a column major way so\n// that a human reading the output will see an array of transposed\n// matrices.\n\ntemplate<typename SCLR>\nostream& operator<<(ostream& os, Frame<SCLR> M)\n{\n  M.write(os, false, false);\n  return os;\n}\n\n// Read in data from a string using scan.\n\ntemplate<typename SCLR>\nFrame<SCLR>& operator<<(Frame<SCLR>& M, const string& s)\n{\n  stringstream ss(s);\n  M.scan(ss, false, false);\n  return M;\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t  // Read / Write //\n//////////////////////////////////////////////////////////////////////\n\n// Writes a matrix.  You may chose to include a header, which are the\n// dimensions of the array of matrices.\n\ntemplate<typename SCLR>\nbool Frame<SCLR>::write(std::ostream& os, bool header, bool binary)\n{\n  if (!os) return false;\n  // Write binary.\n  if(binary){\n    if(header){\n      os.write((char*) &nr, sizeof(nr));\n      os.write((char*) &nc, sizeof(nc));\n      os.write((char*) &nm, sizeof(nm));\n    }\n    for (uint i = 0; i < vol(); i++)\n      os.write((char*) &p[i], sizeof(SCLR));\n  }\n  // Write human.\n  if(!binary){\n    if(header)\n      os << nr << \" \" << nc << \" \" << nm << \"\\n\";\n    for(uint k = 0; k < nm; k++){\n      for(uint j = 0; j < nc; j++){\n\tfor(uint i = 0; i < nr; i++){\n\t  os << operator()(i,j,k) << \" \";\n\t}\n\tos << \"\\n\";\n      }\n      if ((k+1) != nm) os << \"\\n\";\n    }\n  }\n  os.flush();\n  return true;\n} // write\n\n#ifndef DISABLE_FIO\n\ntemplate<typename SCLR>\nbool Frame<SCLR>::write(const string& file, bool header, bool binary)\n{\n  std::ofstream ofs(file.c_str());\n  if (!ofs) return false;\n  return write(ofs, header, binary);\n} // write\n\n#endif\n\n// Reads in data from a string of values until the end of the stream\n// or the end of the array of matrices is reached.  You are alerted if\n// you do not read in enough data to fill the array.\n\ntemplate<typename SCLR>\nuint Frame<SCLR>::scan( std::istream& is, bool header, bool binary)\n{\n  // Tell us if something is wrong.\n  if (!is || is.eof())  return 0;\n\n  uint i = 0; // The nubmer of items read.\n\n  // Read binary.\n  if(binary){\n    if(header){\n      uint r,c,m;\n      is.read((char*) &r, sizeof(nr));\n      is.read((char*) &c, sizeof(nc));\n      is.read((char*) &m, sizeof(nm));\n      // sizecheck(vol() == r*c*m); // A somewhat strict condition.\n    }\n    while(!is.eof() && i < vol())\n      is.read((char*) &p[i++], sizeof(SCLR));\n  }\n  // Write human.\n  if(!binary){\n    if(header){\n      uint r,c,m;\n      is >> r >> c >> m;\n      // sizecheck(vol() == r*c*m); // A somewhat strict condition.\n    }\n    while(!is.eof() && i < vol())\n      { is >> p[i++]; ws(is); } // ws extracts intermediate white space.\n                                // Needed in case the stream is padded by white space.\n  }\n  // Warnings:\n  if (i != vol())\n    fprintf(stderr, \"In scan: Number of items read (%i) different \\\n                     than number of elements in Matrix.\\n\", i);\n  if (!is.eof())\n    fprintf(stderr, \"In scan: Did not reach end of file.\\n\");\n\n  return i;\n} // scan\n\n#ifndef DISABLE_FIO\n\ntemplate<typename SCLR>\nuint Frame<SCLR>::scan(const string& file, bool header, bool binary)\n{\n  std::ifstream ifs(file.c_str());\n  if(!ifs){\n    fprintf(stderr, \"Cannot read file %s.\\n\", file.c_str());\n    return 0;\n  }\n  return scan(ifs, header, binary);\n} // read\n\n#endif\n\n//////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n//                                                                  //\n//     MATRIX OPERATIONS - IE THINGS THAT ONLY USE FIRST MATRIX     //\n//                                                                  //\n//////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n                  // Conformity and Overlap Check //\n//////////////////////////////////////////////////////////////////////\n\n// Check if MF a and MF b overlap in memory.\n\ntemplate<typename SCLR>\nbool overlap(const Frame<SCLR>& a, const Frame<SCLR>& b)\n{\n  // Get the low and the high pointer.\n  const Frame<SCLR> low  = &a(0) < &b(0) ? a : b;\n  const Frame<SCLR> high = &a(0) < &b(0) ? b : a;\n  // Check if there is overlap.  Do we need to subtract 1?  Yes.\n  return (&low(0) + low.area() - 1) < &high(0) ? false : true;\n} // overlap\n\n\n// Hadamard conform.  This is not commutative.  Checks if the size of\n// a is equally divided by the size of b.\n\ntemplate<typename SCLR>\nbool hconform(const Frame<SCLR>& a, const Frame<SCLR>& b)\n{\n  return ( a.area() % b.area() )==0;\n} // hconform\n\n// Matrix product conform.  Checks if c = op(a) * op(b) is valid.\n// Returns 0 if invalid and the matching dimension if valid.\ntemplate<typename SCLR>\nuint pconform(const Frame<SCLR>& c, const Frame<SCLR>& a, const Frame<SCLR>& b, char transa='N', char transb='N')\n{\n  uint opa_rows = transa=='T' ? a.cols() : a.rows();\n  uint opa_cols = transa=='T' ? a.rows() : a.cols();\n  uint opb_rows = transb=='T' ? b.cols() : b.rows();\n  uint opb_cols = transb=='T' ? b.rows() : b.cols();\n  bool conform  = (opa_cols==opb_rows) && (c.rows()==opa_rows) && (c.cols()==opb_cols);\n  if (!conform) {\n    printf(\"c_rows: %u\\n\", c.rows());\n    printf(\"c_cols: %u\\n\", c.cols());\n    printf(\"opa_rows: %u\\n\", opa_rows);\n    printf(\"opa_cols: %u\\n\", opa_cols);\n    printf(\"opb_rows: %u\\n\", opb_rows);\n    printf(\"opb_cols: %u\\n\", opb_cols);\n  }\n  return conform ? opa_cols : 0;\n} // pconform\n\n// Matrices are the same dimension.\ntemplate<typename SCLR>\nbool dconform(const Frame<SCLR>& a, const Frame<SCLR>& b)\n{\n  return ( a.rows()==b.rows() && a.cols()==b.cols() );\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t    // COPYING //\n//////////////////////////////////////////////////////////////////////\n\n// Need to check for alisasing in memory!!!\n\n// This matrix is smaller or the same area as M.\n// Fill this matrix from M starting at (r,c).\ntemplate<typename SCLR>\nvoid Frame<SCLR>::copy(const Frame<SCLR>& M, uint r, uint c)\n{\n  sizecheck( (r + nr) <= M.rows() && (c + nc) <= M.cols() );\n  for(uint j = 0; j < nc; j++)\n    for(uint i = 0; i < nr; i++)\n      operator()(i,j) = M(r+i, c+j);\n} // copy\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::copy(const Frame<SCLR>& M, const Frame<IDX>& rs, const Frame<IDX>& cs)\n{\n  sizecheck(rs.area()==rows() && cs.area()==cols());\n  // Should check min and max of rs and cs to make sure you are in bounds.\n  // I suppose this is checked by indexing.\n  for(uint j = 0; j < cs.area(); j++){\n    for(uint i = 0; i < rs.area(); i++){\n      operator()(i,j) = M(rs(i), cs(j));\n    }\n  }\n} // copy\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::copy(const Frame<SCLR>& M, const Frame<IDX>& rs, uint c)\n{\n  sizecheck(rs.area()==rows() && 1==cols());\n  for(uint i = 0; i < rs.area(); i++){\n    operator()(i,0) = M(rs(i), c);\n  }\n} // copy\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::copy(const Frame<SCLR>& M, uint r, const Frame<IDX>& cs)\n{\n  sizecheck(1==rows() && cs.area()==cols());\n  for(uint j = 0; j < cs.area(); j++){\n    operator()(0,j) = M(r, cs(j));\n  }\n} // copy\n\ntemplate<typename SCLR>\nvoid Frame<SCLR>::copy_transpose(const Frame<SCLR>& M)\n{\n  sizecheck(nr==M.cols() && nc==M.rows() && nm==M.mats());\n  for(uint k = 0; k < nm; ++k){\n    for(uint j = 0; j < nc; ++j){\n      for(uint i = 0; i < nr; ++i){\n\tget(i,j,k) = M.get(j,i,k);\n      }\n    }\n  }\n}\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::set(const Frame<IDX>& rs, const Frame<IDX>& cs, const Frame<SCLR>& M)\n{\n  sizecheck(rs.area()==M.rows() && cs.area()==M.cols());\n  for(uint j = 0; j < cs.area(); j++){\n    for(uint i = 0; i < rs.area(); i++){\n      operator()(rs(i),cs(j)) = M(i, j);\n    }\n  }\n}\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::set(const Frame<IDX>& rs, uint c, const Frame<SCLR>& M)\n{\n  sizecheck(rs.area()==M.area());\n  for(uint i = 0; i < rs.area(); i++){\n    operator()(rs(i), c) = M(i);\n  }\n}\n\ntemplate<typename SCLR> template<typename IDX>\nvoid Frame<SCLR>::set(uint r, const Frame<IDX>& cs, const Frame<SCLR>& M)\n{\n  sizecheck(cs.area()==M.area());\n  for(uint j = 0; j < cs.area(); j++){\n    operator()(r, cs(j)) = M(j);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////\n                      // Operation along rows //\n//////////////////////////////////////////////////////////////////////\n\n// Sometime we want to take an operation \"along rows\" i.e. the\n// operation a(i,j) op= b(j % b.area()) where op may be *,+,/,-.  The\n// functions to do this are <op>onrow where <op> is prod, sum, div, or\n// sub.  We require that a.cols() to be a multiple of area(b).\n\n#define ROWOP(NAME, OPEQ)\t\t\t \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  Frame<SCLR> NAME(Frame<SCLR> a, Frame<SCLR>& b)\t\\\n  {\t\t\t\t\t\t \\\n    memcheck(!overlap(a, b));\t\t\t \\\n    sizecheck(a.cols()%b.area()==0);\t\t \\\n    uint barea = b.area();\t\t\t \\\n    for(uint j = 0; j < a.cols(); j++)\t\t \\\n      for(uint i = 0; i < a.rows(); i++)\t \\\n        a(i,j) OPEQ b(j % barea);\t\t \\\n    return a;\t\t\t\t\t \\\n  }\t\t\t\t\t\t \\\n\nROWOP(prodonrow, *=) ROWOP(sumonrow, +=)\nROWOP(divonrow,  /=) ROWOP(subonrow, -=)\n\n#undef ROWOP\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t// Statistics //\n//////////////////////////////////////////////////////////////////////\n\ntemplate<typename SCLR>\nSCLR sum(const Frame<SCLR>& a)\n{\n  double total = 0.0;\n  for(uint i = 0; i < a.vol(); i++)\n    total += a(i);\n  return total;\n}\n\ntemplate<typename SCLR>\nSCLR mean(const Frame<SCLR>& a)\n{\n  return sum(a) / a.vol();\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t // BLAS / LAPACK //\n//////////////////////////////////////////////////////////////////////\n\n//------------------------------------------------------------------//\n// y = alpha x + y.\ntemplate<typename SCLR>\nvoid axpy(SCLR alpha, Frame<SCLR> x, Frame<SCLR> y)\n{\n  sizecheck(x.rows()==y.rows() && x.cols()==1 && y.cols()==1);\n  raxpy((int)x.rows(), alpha, &x(0), 1, &y(0), 1);\n}\n\n//------------------------------------------------------------------//\n// x'y\ntemplate<typename SCLR>\nSCLR dot(Frame<SCLR> x, Frame<SCLR> y)\n{\n  #ifndef NDEBUG\n  sizecheck(x.rows()==y.rows() && x.cols()==1 && y.cols()==1);\n  #endif\n  return rdot(x.rows(), x.getp(), 1, y.getp(), 1);\n}\n\n//------------------------------------------------------------------//\n// c = alpha op(a) * op(b) + beta c.\n// void gemm(Frame<SCLR> c, Frame<SCLR> a, Frame<SCLR> b, char ta='N', char tb='N', double alpha=1.0, double beta=0.0)\ntemplate<typename SCLR>\nvoid gemm(Frame<SCLR> c, Frame<SCLR> a, Frame<SCLR> b, char ta, char tb, SCLR alpha, SCLR beta)\n{\n  #ifndef NDEBUG\n  memcheck(!overlap(c,a) && !overlap(c,b));\n  #endif\n  // Get the dimensionality information we need.\n  int cnr = (int)c.rows(); int cnc = (int)c.cols();\n  int anr = (int)a.rows(); int bnr = (int)b.rows();\n  int k   = (int)pconform(c, a, b, ta, tb);\n  // Make sure things conform.\n  #ifndef NDEBUG\n  sizecheck(k!=0);\n  #endif\n  rgemm(ta, tb, cnr, cnc, k, alpha, &a(0), anr, &b(0), bnr, beta, &c(0), cnr);\n} // gemm\n\n//------------------------------------------------------------------//\n// b = alpha op(a) * b  OR  b = alpha b * op(a) where a is triangular.\n\n// void trmm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side='L', char ta='N', char diag='N', double alpha=1.0)\ntemplate<typename SCLR>\nvoid trmm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side, char ta, char diag, SCLR alpha)\n{\n  memcheck(!overlap(a,b));\n  // This checks that a is square and that the product conforms.\n  uint k = side=='L' ? pconform(b, a, b, ta, 'N') : pconform(b, b, a, 'N', ta);\n  sizecheck(k!=0);\n  rtrmm(side, uplo, ta, diag, b.rows(), b.cols(), alpha, &a(0), a.rows(), &b(0), b.rows());\n} // trmm\n\n//------------------------------------------------------------------//\n// Solve x:  op(a) x = alpha b  OR  x op(a) = alpha b, a triangular.\n// i.e: x = alpha inv(op(a)) b  OR  x = alpha b inv(op(a)).\n// The solution is overwriten into b.\n\n// void trsm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side='L', char ta='N', char diag='N', double alpha=1.0)\ntemplate<typename SCLR>\nvoid trsm(Frame<SCLR> a, Frame<SCLR> b, char uplo, char side, char ta, char diag, SCLR alpha)\n{\n  memcheck(!overlap(a,b));\n  // This checks that a is square and that the product conforms.\n  uint k = side=='L' ? pconform(b, a, b, ta, 'N') : pconform(b, b, a, 'N', ta);\n  sizecheck(k!=0);\n  rtrsm(side, uplo, ta, diag, b.rows(), b.cols(), alpha, &a(0), a.rows(), &b(0), b.rows());\n} // trsm\n\n//------------------------------------------------------------------------------\n// C := alpha*A*A**T + beta*C, ta='N'\n// C := alpha*A**T*A + beta*C. ta='T'\n\ntemplate<typename SCLR>\nvoid syrk(Frame<SCLR> c, Frame<SCLR> a, char ta, SCLR alpha, SCLR beta)\n{\n  memcheck(!overlap(c,a));\n  char tb = ta=='N' ? 'T' : 'N';\n  pconform(c, a, a, ta, tb);\n  int k = ta=='N' ? a.cols() : a.rows();\n  \n  rsyrk('U', ta, c.rows(), k, alpha, &a(0), a.rows(), beta, &c(0), c.rows());\n\n  // Better way?\n  for(uint j=0; j<c.cols()-1; j++)\n    for(uint i=j+1; i<c.rows(); i++)\n      c(i,j) = c(j,i);\n}\n\n//////////////////////////////////////////////////////////////////////\n\t\t  // MATRIX FRAME LAPACK WRAPPER //\n//////////////////////////////////////////////////////////////////////\n\n// Solve a general linear system, ax = b for x.\n\ntemplate<typename SCLR>\nint gesv(Frame<SCLR> a, Frame<SCLR> b)\n{\n  memcheck(!overlap(a, b));       // No overlap in memory.\n  sizecheck(pconform(b, a, b)!=0); // a is square and b conforms.\n  int info;\n  std::vector<int> ipiv(a.rows());\n  rgesv(a.rows(), b.cols(), &a(0), a.rows(), &ipiv[0], &b(0), b.rows(), info);\n  return info;\n}\n\n// Shorthand.\ntemplate<typename SCLR>\nint solve(Frame<SCLR> a, Frame<SCLR> b)\n{\n  return gesv(a, b);\n}\n\n//------------------------------------------------------------------//\n// Solves ax = b for x where a is sym. pos. def.  Note: the lower (or\n// upper) portion of A is overwritten with the Cholesky decomposition.\n\ntemplate<typename SCLR>\nint posv(Frame<SCLR> a, Frame<SCLR> b, char uplo)\n{\n  memcheck(!overlap(a,b));\n  sizecheck(pconform(b, a, b)!=0);\n  int info;\n  rposv(uplo, a.rows(), b.cols(), &a(0), a.rows(), &b(0), b.rows(), info);\n\n  if (info != 0) {\n    printf(\"Error in posv: info = %i\\n\", info);\n    #ifndef NTHROW\n    throw std::runtime_error(\"aborted in posv\\n\");\n    #endif\n  }\n\n  return info;\n}\n\n//------------------------------------------------------------------//\n// Cholesky Decomposition\n\ntemplate<typename SCLR>\nint potrf(Frame<SCLR> a, char uplo)\n{\n  sizecheck(a.rows()==a.cols());\n  int info = 0;\n  rpotrf(uplo, a.rows(), &a(0), a.rows(), info);\n  return info;\n}\n\n// int chol(Frame<SCLR> a, char uplo='L')\ntemplate<typename SCLR>\nint chol(Frame<SCLR> a, char uplo)\n{\n  return potrf(a, uplo);\n}\n\n//------------------------------------------------------------------//\n\n//////////////////////////////////////////////////////////////////////\n                      // Hadamard Operations //\n//////////////////////////////////////////////////////////////////////\n\n// A Hadamard operation is an operation done element wise.\n// Notationally, given op in {*,+,/,-} these functions perform\n// something like\n\n//    a[i] op= b[i % b.area()]\n//    c[i] = alpha * a[i] op b[i % b.area()] + beta c[i].\n\n// Thus the elements of b are recycled when area(b) < area(a).  We\n// require that area(b) be a multiple of area(a).\n\n// The functions available are h<op>eq(a, b, sc) and h<op>(c, a, b,\n// alpha=0.0, beta=1.0) where <op> is prod, sum, div, or sub.\n\n// Hadamard Operation Equals (HOPEQ) a op= sc * b\n#define HOPEQ(NAME, OPEQ)\t\t\t\t\t\t\\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  Frame<SCLR> NAME(Frame<SCLR> a, const Frame<SCLR>& b, SCLR sc=1.0) \\\n  {                                                                     \\\n    memcheck(!overlap(a,b));                                              \\\n    sizecheck(hconform(a,b));                                              \\\n    uint barea = b.area();\t\t\t\t\t\t\\\n    for(uint i = 0; i < a.area(); i++)\t\t\t\t\t\\\n      a(i) OPEQ sc * b(i % barea);\t\t\t\t\t\\\n    return a;\t\t\t\t\t\t\t\t\\\n  }                                                                     \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  Frame<SCLR> NAME(Frame<SCLR> a, SCLR b)\t\t\t\\\n  {                                                                     \\\n    for(uint i = 0; i < a.area(); i++)\t\t\t\t\t\\\n      a(i) OPEQ b;\t\t\t\t\t\t\t\\\n    return a;\t\t\t\t\t\t\t\t\\\n  }                                                                     \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  Frame<SCLR>& operator OPEQ(Frame<SCLR>& a, const Frame<SCLR>& b) \\\n  {                                                                     \\\n    memcheck(!overlap(a,b));                                              \\\n    sizecheck(hconform(a,b));                                              \\\n    uint barea = b.area();\t\t\t\t\t\t\\\n    for(uint i = 0; i < a.area(); i++)\t\t\t\t\t\\\n      a(i) OPEQ b(i % barea);\t\t\t\t\t\t\\\n    return a;\t\t\t\t\t\t\t\t\\\n  }\t\t\t\t\t\t\t\t\t\\\n\nHOPEQ(hprodeq, *=) HOPEQ(hsumeq, +=)\nHOPEQ(hdiveq,  /=) HOPEQ(hsubeq, -=)\n\n#undef HOPEQ\n\n// Hadamard Operation (HOP) c = a op sc * b\n#define HOP(NAME, OP)                                                   \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  void NAME(Frame<SCLR> c, const Frame<SCLR>& a, const Frame<SCLR>& b, double alpha=1.0, double beta=0.0)\t\\\n  {                                                                     \\\n    bool okay = (!overlap(c,b) && !overlap(a,b)) ||\t\t\t\\\n      (!overlap(c,a) && !overlap(c,b));\t\t\t\t\t\\\n    memcheck(okay);\t\t\t\t\t\t\t\\\n    sizecheck(hconform(a,b));                                              \\\n    sizecheck(c.area()==a.area());\t\t\t\t\t\t\\\n    uint barea = b.area();\t\t\t\t\t\t\\\n    for(uint i = 0; i < c.area(); i++)\t\t\t\t\t\\\n      c(i) = alpha * a(i) OP b(i % barea) + beta * c(i);\t\t\\\n  }                                                                     \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  void NAME(Frame<SCLR> c, const Frame<SCLR>& a, double b)                                      \\\n  {                                                                     \\\n    sizecheck(c.area()==a.area());\t\t\t\t\t\t\\\n    for(uint i = 0; i < c.area(); i++)\t\t\t\t\t\\\n      c(i) = a(i) OP b;                                                 \\\n  }                                                                     \\\n  template<typename SCLR>\t\t\t\t\t\t\\\n  void NAME(Frame<SCLR> c, double b, const Frame<SCLR>& a)\t\t\t\t\t\\\n  {                                                                     \\\n    sizecheck(c.area()==a.area());\t\t\t\t\t\t\\\n    for(uint i = 0; i < c.area(); i++)\t\t\t\t\t\\\n      c(i) = b OP a(i);                                                 \\\n  }                                                                     \\\n\nHOP(hprod, *) HOP(hsum, +)\nHOP(hdiv,  /) HOP(hsub, -)\n\n#undef HOP\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t  // END OF CODE //\n//////////////////////////////////////////////////////////////////////\n\n#endif // MATRIX_FRAME\n\n//////////////////////////////////////////////////////////////////////\n\t\t\t    // APPENDIX //\n//////////////////////////////////////////////////////////////////////\n\n/*********************************************************************\n\n  The goal of the matrixMatrixFrame class and the Matrix class is to\n  represent arrays of matrices.  An array with only one matrix can be\n  thought of simply as a matrix.  We had three goals in mind when\n  creating this clss: 1) keep it simple/transparent, 2) make it easy\n  to use in MCMC, and 3) make it easy to talk to R.\n\n  Regarding (1), there is a tradeoff between ease of understanding the\n  code and ease of calculations.  Eigen is a great Matrix package, but\n  it is hard to understand what exactly is going on.  I don't\n  understand expression templates, but they make calculations nice and\n  easy.  Since this will be used in MCMC simulations we wanted to know\n  exactly what is going on under the hood, which means that this code\n  is more understandable but that you will pay a cost when expressing\n  your computations.\n\n  Regarding (2), we hope that an array of Matrices will be sufficient\n  for most MCMC algorithms.  It is possible that one may need an array\n  of an array of matrices, such as an Matrix Normal DLM within a Gibbs\n  sampler, but we haven't ecountered that too often in our MCMC\n  experience.\n\n  Regarding (3), you should be able to pass the pointer to some data\n  from R directly to the MatrixFrame class to set up your data\n  structure.\n\n  You can think of the MatrixFrame class as simply a wrapper to\n  BLAS/LAPACK, and you can think of the Matrix class as a simple data\n  container.  That's all there is too it.  In that sense, MatrixFrame\n  is an \"interface\".  The matrix operations are ALWAYS performed on\n  the first matrix in the array.  If you want to perform an operation\n  on different matrix in the array use the [] operator.\n\n  Below you will find that the class is split into two categories:\n  those parts of the class that have to do with the array of matrices\n  and those parts of the class that have to do with the first matrix\n  in the array, i.e. the matrix on which we are operating.\n\n  In general, we need to be careful with this class.  There are lots\n  of opportunities to break things since the class possess a pointer\n  to some data, which the class itself did not create.\n\n  Everything is COLUMN MAJOR for compatibility with Fortran.\n\n  Idea: You could template this to the dimension of the array.\n\n*********************************************************************/\n",
    "created" : 1368413003025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2579641500",
    "id" : "B9BC338C",
    "lastKnownWriteTime" : 1354732890,
    "path" : "~/Documents/Research/political_science/testpkg1/src/MatrixFrame.h",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "h"
}